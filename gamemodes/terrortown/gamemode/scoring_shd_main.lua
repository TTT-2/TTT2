-- Server and client both need this for scoring event logs

function ScoreInit()
	local _tbl = {
		deaths = 0,
		suicides = 0,
		lt = "", -- last team
		lr = "", -- last role
		ev = { -- on doing a kill event with different data
			--r = ROLE_INNOCENT, -- subrole at the moment of the event
			--t = "", -- team at the moment of the event
			--v = "" -- victims team at the moment of the event
		},
		bonus = 0 -- non-kill points to add
	}

	return _tbl
end

function ScoreEventInit()
	local _tbl = {
		r = ROLE_INNOCENT, -- subrole at the moment of the event
		t = "", -- team at the moment of the event
		v = "" -- victims team at the moment of the event
	}

	return _tbl
end

function ScoreEvent(e, scores)
	if e.id == EVENT_KILL then
		local aid = e.att.sid64
		local vid = e.vic.sid64

		-- make sure a score table exists for this person
		-- he might have disconnected by now
		scores[vid] = scores[vid] or ScoreInit()

		-- normally we have the ply:GetTraitor stuff to base this on, but that
		-- won't do for disconnected players
		scores[aid] = scores[aid] or ScoreInit()

		scores[vid].deaths = scores[vid].deaths + 1
		scores[vid].lt = e.vic.t
		scores[vid].lr = e.vic.r

		if aid == vid then
			scores[vid].suicides = scores[vid].suicides + 1
		elseif aid ~= -1 then
			local eva = ScoreEventInit()
			eva.r = e.att.r
			eva.t = e.att.t
			eva.v = e.vic.t

			scores[aid].ev[#scores[aid].ev + 1] = eva
			scores[aid].lt = e.att.t
			scores[aid].lr = e.att.r
		end
	elseif e.id == EVENT_BODYFOUND then
		local sid64 = e.sid64

		scores[sid64] = scores[sid64] or ScoreInit()

		if e.t == TEAM_TRAITOR then return end

		local find_bonus = e.r == ROLE_DETECTIVE and 3 or 1

		scores[sid64].bonus = scores[sid64].bonus + find_bonus
	end
end

-- events should be event log as generated by scoring.lua
-- scores should be table with SteamIDs as keys
-- The method of finding these IDs differs between server and client
function ScoreEventLog(events, scores)
	for k in pairs(scores) do
		scores[k] = ScoreInit()
	end

	for _, e in pairs(events) do
		ScoreEvent(e, scores)
	end

	return scores
end

function ScoreTeamBonus(scores, wintype)
	local alive = {}
	local dead = {}

	-- who's alive, who dead?
	for _, sc in pairs(scores) do
		local state = (sc.deaths == 0) and alive or dead

		local team = sc.lt
		if team ~= TEAM_NONE then
			state[team] = (state[team] or 0) + 1
		end
	end

	local bonus = {}

	for id, sc in pairs(scores) do
		local team = sc.lt
		local roleData = GetRoleByIndex(sc.lr)
		local others = 0

		for other, amount in pairs(dead) do
			if team ~= TEAM_NONE and team ~= other then
				others = others + amount
			end
		end

		bonus[id] = (alive[team] or 0) + math.ceil(others * (roleData.surviveBonus or 0))
	end

	-- running down the clock must never be beneficial for traitors
	if wintype == WIN_TIMELIMIT then
		local alive_not_traitors = 0
		local dead_not_traitors = 0

		for k, x in pairs(alive) do
			if k ~= TEAM_TRAITOR then
				alive_not_traitors = alive_not_traitors + x
			end
		end

		for k, x in pairs(dead) do
			if k ~= TEAM_TRAITOR then
				dead_not_traitors = dead_not_traitors + x
			end
		end

		local _val = math.floor(alive_not_traitors * -0.5) + math.ceil(dead_not_traitors * 0.5)

		for id, sc in pairs(scores) do
			bonus[id] = (sc.lt == TEAM_TRAITOR) and _val or bonus[id]
		end
	end

	return bonus
end

-- Scores were initially calculated as points immediately, but not anymore, so
-- we can convert them using this fn
function KillsToPoints(score)
	local sc = score.bonus - score.suicides + (score.deaths == 0 and 1 or 0)

	for _, ev in ipairs(score.ev) do
		local roleData = GetRoleByIndex(ev.r)

		if ev.t ~= TEAM_NONE and ev.t == ev.v then -- teamkill
			sc = sc + roleData.scoreTeamKillsMultiplier
		else -- legit kill
			sc = sc + roleData.scoreKillsMultiplier
		end
	end

	return sc
end

---- Weapon AMMO_ enum stuff, used only in score.lua/cl_score.lua these days

-- Not actually ammo identifiers anymore, but still weapon identifiers. Used
-- only in round report (score.lua) to save bandwidth because we can't use
-- pooled strings there. Custom SWEPs are sent as classname string and don't
-- need to bother with these.
AMMO_DEAGLE = 2
AMMO_PISTOL = 3
AMMO_MAC10 = 4
AMMO_RIFLE = 5
AMMO_SHOTGUN = 7
-- Following are custom, intentionally out of ammo enum range
AMMO_CROWBAR = 50
AMMO_SIPISTOL = 51
AMMO_C4 = 52
AMMO_FLARE = 53
AMMO_KNIFE = 54
AMMO_M249 = 55
AMMO_M16 = 56
AMMO_DISCOMB = 57
AMMO_POLTER = 58
AMMO_TELEPORT = 59
AMMO_RADIO = 60
AMMO_DEFUSER = 61
AMMO_WTESTER = 62
AMMO_BEACON = 63
AMMO_HEALTHSTATION = 64
AMMO_MOLOTOV = 65
AMMO_SMOKE = 66
AMMO_BINOCULARS = 67
AMMO_PUSH = 68
AMMO_STUN = 69
AMMO_CSE = 70
AMMO_DECOY = 71
AMMO_GLOCK = 72

local WeaponNames

function GetWeaponClassNames()
	if not WeaponNames then
		local tbl = {}

		for _, v in ipairs(weapons.GetList()) do
			if v and v.WeaponID then
				tbl[v.WeaponID] = WEPS.GetClass(v)
			end
		end

		for _, v in pairs(scripted_ents.GetList()) do
			local id = v and (v.WeaponID or (v.t and v.t.WeaponID))

			if id then
				tbl[id] = WEPS.GetClass(v)
			end
		end

		WeaponNames = tbl
	end

	return WeaponNames
end

-- reverse lookup from enum to SWEP table
function EnumToSWEP(ammo)
	local e2w = GetWeaponClassNames() or {}

	if e2w[ammo] then
		return util.WeaponForClass(e2w[ammo])
	else
		return
	end
end

function EnumToSWEPKey(ammo, key)
	local swep = EnumToSWEP(ammo)

	return swep and swep[key]
end

-- something the client can display
-- This used to be done with a big table of AMMO_ ids to names, now we just use
-- the weapon PrintNames. This means it is no longer usable from the server (not
-- used there anyway), and means capitalization is slightly less pretty.
function EnumToWep(ammo)
	return EnumToSWEPKey(ammo, "PrintName")
end

-- something cheap to send over the network
function WepToEnum(wep)
	if not IsValid(wep) then return end

	return wep.WeaponID
end
